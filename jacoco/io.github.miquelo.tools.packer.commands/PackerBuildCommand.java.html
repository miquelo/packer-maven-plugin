<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PackerBuildCommand.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Packer Maven Plugin</a> &gt; <a href="index.source.html" class="el_package">io.github.miquelo.tools.packer.commands</a> &gt; <span class="el_source">PackerBuildCommand.java</span></div><h1>PackerBuildCommand.java</h1><pre class="source lang-java linenums">package io.github.miquelo.tools.packer.commands;

import static io.github.miquelo.tools.packer.PackerCommandFailureCode
    .FAILURE_ERROR;
import static java.lang.String.format;
import static java.nio.file.Files.walk;
import static java.util.Collections.emptySet;
import static java.util.Objects.requireNonNull;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import static javax.xml.bind.DatatypeConverter.parseHexBinary;
import static javax.xml.bind.DatatypeConverter.printHexBinary;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.UncheckedIOException;
import java.nio.file.Path;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeoutException;
import java.util.stream.Stream;

import io.github.miquelo.tools.packer.PackerCommand;
import io.github.miquelo.tools.packer.PackerCommandException;
import io.github.miquelo.tools.packer.PackerCommandFailureCode;
import io.github.miquelo.tools.packer.PackerCommandLogger;
import io.github.miquelo.tools.packer.TimeoutHandler;

/**
 * Packer {@code build} command.
 */
public class PackerBuildCommand
implements PackerCommand
{
    private static final String COMMAND_NAME = &quot;build&quot;;

    private static final String CHECKSUM_FILE_NAME = &quot;.checksum&quot;;
    private static final String CHECKSUM_ALGORITHM = &quot;SHA-256&quot;;
    
    private static final int DIGEST_BUFFER_SIZE = 4 * 1024;
    
    private final MessageDigestCreator digestCreator;
    private final File inputDir;
    private final boolean changesNeeded;
    private final boolean invalidateOnFailure;
    private final List&lt;Object&gt; arguments;
    private final File checksumFile;
    
    /**
     * Packer {@code build} command complete constructor.
     * 
     * @param digestCreator
     *     Message digest used to obtain input files hash.
     * @param inputDir
     *     Directory where input files are located.
     * @param changesNeeded
     *     Whether changes on source files are needed for this command to don't
     *     be ignored.
     * @param invalidateOnFailure
     *     Whether files will be invalidated if command executions fails.
     * @param templatePath
     *     Input directory relative path of template used for this build.
     * @param only
     *     Set of builder names that must be taken into account. Empty for all.
     * @param except
     *     Set of builder names that must be ignored.
     * @param force
     *     Whether execution should overwrite Packer output directory.
     * @param vars
     *     Variables used for this build.
     * @param varFiles
     *     Variable files used for this build.
     */
    public PackerBuildCommand(
        MessageDigestCreator digestCreator,
        File inputDir,
        boolean changesNeeded,
        boolean invalidateOnFailure,
        String templatePath,
        boolean force,
        Set&lt;String&gt; only,
        Set&lt;String&gt; except,
        Map&lt;String, Object&gt; vars,
        Set&lt;String&gt; varFiles)
<span class="nc" id="L98">    {</span>
<span class="nc" id="L99">        this.digestCreator = requireNonNull(digestCreator);</span>
<span class="nc" id="L100">        this.inputDir = requireNonNull(inputDir);</span>
<span class="nc" id="L101">        this.changesNeeded = changesNeeded;</span>
<span class="nc" id="L102">        this.invalidateOnFailure = invalidateOnFailure;</span>
        
<span class="nc bnc" id="L104" title="All 2 branches missed.">        arguments = Stream.of(</span>
<span class="nc" id="L105">            force ? Stream.of(&quot;-force&quot;) : Stream.empty(),</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">            only.isEmpty() ? Stream.empty() : Stream.of(</span>
                &quot;-only&quot;,
<span class="nc" id="L108">                only.stream()</span>
<span class="nc" id="L109">                    .collect(joining(&quot;,&quot;))),</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            except.isEmpty() ? Stream.empty() : Stream.of(</span>
                &quot;-except&quot;,
<span class="nc" id="L112">                except.stream()</span>
<span class="nc" id="L113">                    .collect(joining(&quot;,&quot;))),</span>
<span class="nc" id="L114">            vars.entrySet().stream()</span>
<span class="nc" id="L115">                .flatMap(var -&gt; Stream.of(</span>
                    &quot;-var&quot;,
<span class="nc" id="L117">                    String.format(</span>
                        &quot;%s=%s&quot;,
<span class="nc" id="L119">                        var.getKey(),</span>
<span class="nc" id="L120">                        var.getValue().toString()))),</span>
<span class="nc" id="L121">            varFiles.stream()</span>
<span class="nc" id="L122">                .flatMap(varFile -&gt; Stream.of(</span>
                    &quot;-var-file&quot;,
                    varFile)),
<span class="nc" id="L125">            Stream.of(templatePath))</span>
<span class="nc" id="L126">            .flatMap(identity())</span>
<span class="nc" id="L127">            .collect(toList());</span>
        
<span class="nc" id="L129">        checksumFile = new File(this.inputDir, CHECKSUM_FILE_NAME);</span>
<span class="nc" id="L130">    }</span>
    
    @Override
    public String getName()
    {
<span class="nc" id="L135">        return COMMAND_NAME;</span>
    }

    @Override
    public List&lt;Object&gt; getArguments()
    {
<span class="nc" id="L141">        return arguments;</span>
    }
    
    @Override
    public Optional&lt;File&gt; getWorkingDir()
    {
<span class="nc" id="L147">        return Optional.of(inputDir);</span>
    }
    
    @Override
    public boolean init(
        PackerCommandLogger logger,
        TimeoutHandler timeoutHandler)
    throws PackerCommandException, TimeoutException
    {
<span class="nc" id="L156">        logger.debug(format(&quot;Using %s as input directory&quot;, inputDir));</span>
        
<span class="nc" id="L158">        Set&lt;ChecksumEntry&gt; currentChecksum = currentChecksumGet();</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (!currentChecksum.equals(previousChecksumGet()))</span>
        {
<span class="nc" id="L161">            checksumUpdate(currentChecksum);</span>
<span class="nc" id="L162">            return true;</span>
        }
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (changesNeeded)</span>
        {
<span class="nc" id="L166">            logger.info(&quot;There is not any change. Ignoring...&quot;);</span>
<span class="nc" id="L167">            return false;</span>
        }
<span class="nc" id="L169">        return true;</span>
    }
    
    public void onSuccess()
    {
        // Nothing to be done...
<span class="nc" id="L175">    }</span>
    
    @Override
    public void onFailure(PackerCommandFailureCode failureCode)
    {
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (invalidateOnFailure)</span>
<span class="nc" id="L181">            checksumFile.delete();</span>
<span class="nc" id="L182">    }</span>
    
    @Override
    public void onAbort()
    {
<span class="nc" id="L187">        checksumFile.delete();</span>
<span class="nc" id="L188">    }</span>
    
    @Override
    public PackerCommandFailureCode mapFailureCode(int errorCode)
    {
<span class="nc" id="L193">        return FAILURE_ERROR;</span>
    }
    
    private Set&lt;ChecksumEntry&gt; currentChecksumGet()
    throws PackerCommandException
    {
        try
        {
<span class="nc" id="L201">            return walk(inputDir.toPath())</span>
<span class="nc" id="L202">                .filter(this::isRegularFile)</span>
<span class="nc" id="L203">                .filter(this::isNotChecksumFile)</span>
<span class="nc" id="L204">                .map(this::toChecksumEntry)</span>
<span class="nc" id="L205">                .collect(toSet());</span>
        }
<span class="nc" id="L207">        catch (IOException exception)</span>
        {
<span class="nc" id="L209">            throw new PackerCommandException(exception);</span>
        }
<span class="nc" id="L211">        catch (</span>
            UncheckedIOException |
            UncheckedNoSuchAlgorithmException exception)
        {
<span class="nc" id="L215">            throw new PackerCommandException(exception.getCause());</span>
        }
    }
    
    private Set&lt;ChecksumEntry&gt; previousChecksumGet()
    throws PackerCommandException
    {
<span class="nc" id="L222">        try (BufferedReader reader = newBufferedReader(checksumFile))</span>
        {
<span class="nc" id="L224">            return reader.lines()</span>
<span class="nc" id="L225">                .map(ChecksumEntry::parse)</span>
<span class="nc" id="L226">                .collect(toSet());</span>
        }
<span class="nc" id="L228">        catch (FileNotFoundException exception)</span>
        {
<span class="nc" id="L230">            return emptySet();</span>
        }
<span class="nc" id="L232">        catch (IOException exception)</span>
        {
<span class="nc" id="L234">            throw new PackerCommandException(exception);</span>
        }
<span class="nc" id="L236">        catch (UncheckedIOException exception)</span>
        {
<span class="nc" id="L238">            throw new PackerCommandException(exception.getCause());</span>
        }
    }
    
    private void checksumUpdate(Set&lt;ChecksumEntry&gt; checksum)
    throws PackerCommandException
    {
<span class="nc" id="L245">        try (PrintWriter writer = new PrintWriter(checksumFile))</span>
        {
<span class="nc" id="L247">            checksum.forEach(entry -&gt; writer.println(entry));</span>
        }
<span class="nc" id="L249">        catch (FileNotFoundException exception)</span>
        {
<span class="nc" id="L251">            createNewFile(checksumFile);</span>
        }
<span class="nc" id="L253">        catch (UncheckedIOException exception)</span>
        {
<span class="nc" id="L255">            throw new PackerCommandException(exception.getCause());</span>
<span class="nc" id="L256">        }</span>
<span class="nc" id="L257">    }</span>
    
    private boolean isRegularFile(Path path)
    {
<span class="nc" id="L261">        return path.toFile().isFile();</span>
    }
    
    private boolean isNotChecksumFile(Path path)
    {
<span class="nc" id="L266">        return !path.toAbsolutePath()</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            .equals(checksumFile.getAbsoluteFile().toPath());</span>
    }
    
    private ChecksumEntry toChecksumEntry(Path path)
    {
<span class="nc" id="L272">        try (InputStream input = new FileInputStream(path.toFile()))</span>
        {
<span class="nc" id="L274">            MessageDigest digest = digestCreator.create(CHECKSUM_ALGORITHM);</span>
<span class="nc" id="L275">            byte[] buf = new byte[DIGEST_BUFFER_SIZE];</span>
<span class="nc" id="L276">            int len = input.read(buf, 0, DIGEST_BUFFER_SIZE);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            while (len &gt; 0)</span>
            {
<span class="nc" id="L279">                digest.update(buf, 0, len);</span>
<span class="nc" id="L280">                len = input.read(buf, 0, DIGEST_BUFFER_SIZE);</span>
            }
<span class="nc" id="L282">            return new ChecksumEntry(buf, path.toString());</span>
        }
<span class="nc" id="L284">        catch (IOException exception)</span>
        {
<span class="nc" id="L286">            throw new UncheckedIOException(exception);</span>
        }
<span class="nc" id="L288">        catch (NoSuchAlgorithmException exception)</span>
        {
<span class="nc" id="L290">            throw new UncheckedNoSuchAlgorithmException(exception);</span>
        }
    }
    
    private static BufferedReader newBufferedReader(File file)
    throws IOException
    {
<span class="nc" id="L297">        return new BufferedReader(new FileReader(file));</span>
    }
    
    private static void createNewFile(File file)
    throws PackerCommandException
    {
        try
        {
<span class="nc" id="L305">            file.createNewFile();</span>
        }
<span class="nc" id="L307">        catch (IOException exception)</span>
        {
<span class="nc" id="L309">            throw new PackerCommandException(exception);</span>
<span class="nc" id="L310">        }</span>
<span class="nc" id="L311">    }</span>
}

class ChecksumEntry
{
    private final byte[] hash;
    private final String path;
    
    ChecksumEntry(byte[] hash, String path)
<span class="nc" id="L320">    {</span>
<span class="nc" id="L321">        this.hash = requireNonNull(hash);</span>
<span class="nc" id="L322">        this.path = requireNonNull(path);</span>
<span class="nc" id="L323">    }</span>
    
    @Override
    public int hashCode()
    {
<span class="nc" id="L328">        return Arrays.hashCode(hash);</span>
    }
    
    @Override
    public boolean equals(Object obj)
    {
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L335">            return true;</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (getClass().equals(obj.getClass()))</span>
        {
<span class="nc" id="L338">            ChecksumEntry entry = (ChecksumEntry) obj;</span>
<span class="nc bnc" id="L339" title="All 4 branches missed.">            return Arrays.equals(hash, entry.hash) &amp;&amp; path.equals(entry.path);</span>
        }
<span class="nc" id="L341">        return false;</span>
    }
    
    @Override
    public String toString()
    {
<span class="nc" id="L347">        return format(&quot;%s %s&quot;, toString(hash), path);</span>
    }
    
    static ChecksumEntry parse(String str)
    {
<span class="nc" id="L352">        String[] parts = str.split(&quot; &quot;);</span>
<span class="nc" id="L353">        return new ChecksumEntry(toBytes(parts[0]), parts[1]);</span>
    }
    
    private static byte[] toBytes(String str)
    {
<span class="nc" id="L358">        return parseHexBinary(str);</span>
    }
    
    private static String toString(byte[] bytes)
    {
<span class="nc" id="L363">        return printHexBinary(bytes);</span>
    }
}

class UncheckedNoSuchAlgorithmException
extends RuntimeException
{
    private static final long serialVersionUID = 1L;

    UncheckedNoSuchAlgorithmException(NoSuchAlgorithmException cause)
    {
<span class="nc" id="L374">        super(cause);</span>
<span class="nc" id="L375">    }</span>
    
    @Override
    public NoSuchAlgorithmException getCause()
    {
<span class="nc" id="L380">        return (NoSuchAlgorithmException) super.getCause();</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>